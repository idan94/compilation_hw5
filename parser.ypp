%{
   #include "hw3_output.hpp"
   #include <stack>
   #include <iostream>
   #include <map>
   #include <string>
   #include <vector>
   #include <assert.h>
   #include <set>
   #include "structs.hpp"
   #include "utils.hpp"
   #include <algorithm>
   #include <functional>
   #include <queue>
   #include "utils.hpp"
   #include "bp.hpp"
   
   using namespace std;

   extern int yylineno;
   const string WHILE_SCOPE = "while_scope";
   const string REGULAR_SCOPE = "regular_scope";
   const string TYPE_INT    = "INT";
   const string TYPE_BOOL   = "BOOL";
   const string TYPE_BYTE   = "BYTE";
   const string TYPE_STRING = "STRING";
   const string TYPE_VOID = "VOID";

   vector<map<string,pair<string, int>>>* tables;
   vector<Scope>* scopes;
   vector<queue<string>>* insertion_orders;
   stack<int>* offsets;
   stack<vector<pair<int, BranchLabelIndex>>>* break_next_lists;
   stack<string>* continue_labels;
   map<string,pair<string, int>>* t;
   CurrentStackRegister* current_stack_register;


   int yylex();
   void yyerror(const char*);

   bool name_exists_in_table(const string name,const vector<map<string, pair<string, int>>> &tables, bool is_fun=false);
   /* Rule #8 hw's PDF */
   string relop(string a, string b);
   /* Rule #9 hw's PDF */
   string log_eq(string a, string b);
   /* Rule #10 hw's PDF */
   string binop(string a, string b);
   /* Rule #16 hw's PDF */
   void check_bool_exp(string exp_type);
   void pop_tables();
   void pop_offsets();
   void push_tables();
   void push_offsets(int offset);
   map<string,pair<string, int>> &top_tables();
   int &top_offsets();
   void insert(const string& name, const string& type,int offset, bool is_fun=true);
   void yyerror(const char*);
   void push_regular_scope();
   void pop_scope();
   void push_while_scope();
   bool check_while_scope();
   void assign_type_check(string var,string exp);
   bool is_id_function(const string& name, const vector<map<string, pair<string, int>>> &tables);
   string get_id_type(const string name, const vector<map<string, pair<string, int>>> &tables);
   int get_id_offset(const string name, const vector<map<string, pair<string, int>>> &tables);
   int get_id_dest_from_last_scope(const string name, const vector<map<string, pair<string, int>>> &tables);
   int get_id_last_stack(const string name, const vector<map<string, pair<string, int>>> &tables);
   string get_current_function_return_type(const vector<queue<string>> stack_queues);
   string vectorToString(const std::vector<string>& argTypes);
   vector<string> split_str(string str, string delimiter);
   void print_map_by_order(map<string, pair<string, int>> scope_map,queue<string> orders);

   
%}

%union{
   int number;
   string* type;
   string* op;
   bool bool_value;
   string* id_name;
   string* str;
   string* return_type;
   vector<pair<int,BranchLabelIndex>>* branch_location;
   Expression* expression;
   CallFunction* call_function;
   /* Statement* statment; */
   Formal* formal;
   string* label;
   int label_pointer;
   vector<pair<int,BranchLabelIndex>>* short_circuit_list; //for short_circuit OR/AND
}

%nonassoc VOID    
%nonassoc INT     
%nonassoc BYTE    
%nonassoc B       
%nonassoc BOOL    
%nonassoc TRUE    
%nonassoc FALSE   
%nonassoc RETURN  
%nonassoc IF      
%nonassoc WHILE   
%nonassoc BREAK   
%nonassoc CONTINUE
%nonassoc SC      
%nonassoc COMMA   
%nonassoc LBRACE  
%nonassoc RBRACE  
%right ASSIGN 
%left OR   
%left AND    
%left <op> EQUALITY_RELOP   
%nonassoc <op> RELATIONAL_RELOP
%left <op> ADD_BINOP 
%left <op> MUL_BINOP  
%right NOT    
%left LPAREN  
%left RPAREN 
%nonassoc ELSE //Take Else Before RPAREN ')'
%nonassoc <id_name> ID      
%nonassoc <number> NUM     
%nonassoc <str> STRING  

%type <short_circuit_list> ShortCircuitAnd;
%type <short_circuit_list> ShortCircuitOr;
%type <expression> Exp
%type <type> RetType
%type <formal> Formals
%type <formal> FormalsList
%type <formal> FormalsDecl
%type <call_function> Call
%type <expression> ExpList
%type <type> Type
/* %type <statment> Statement */
/* %type <statment> Statements */
%type <label> Marker5
%type <label> Marker2;
%type <label> Marker4;
%type <branch_location> NMarker2;
%type <label_pointer> NMarker1;
%type <label_pointer> NMarker3;


%%

Program:       Marker1 Funcs       {
   if(!name_exists_in_table("main",*tables,true)){
      output::errorMainMissing();
      exit(0);
   }else{
      string fun_sign = get_id_type("main" ,*tables);
      string ret_type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
      string function_args = fun_sign.substr(0,fun_sign.find("->"));
      if(ret_type.compare(TYPE_VOID) || function_args.compare("()")){
         output::errorMainMissing();
         exit(0);
      }
   }
   //output::endScope();
   print_map_by_order(tables->back(),insertion_orders->back());
   pop_tables();
   pop_offsets();
   utils_hw5::print_buffers();
}
;
Marker1:       /*epsilon*/       {
      push_tables();
      push_offsets(0);
      vector<string> args_to_print;
      utils_hw5::start_llvm_code();
      args_to_print.push_back(TYPE_STRING);
      insert("print", output::makeFunctionType(TYPE_VOID, args_to_print),0, true);
      utils_hw5::add_print_function();
      args_to_print.clear();
      args_to_print.push_back(TYPE_INT);
      insert("printi", output::makeFunctionType(TYPE_VOID, args_to_print),0, true);
      utils_hw5::add_printi_function();
      push_regular_scope();
      //HW5:

      //allocating the stack for the global veriables
      // we assume that there will be less then 50 global veriables
      //TODO: check that, it is not written! 
      // current_stack_register->push(utils_hw5::fresh_var());
      // utils_hw5::allocate_new_stack(current_stack_register->top());

      // this function returns a pointer to the top of the stack
       //HW5~
}
Funcs:         /*epsilon*/       {}
               | FuncDecl Funcs        {}
;
FuncDecl:      FuncDeclPart1 FuncDeclPart2 {
                   // HW5:
                   // emit the code for the decleration of the function
                  // HW5~
                  }
;
FuncDeclPart1:  RetType ID LPAREN Formals RPAREN{      
                  auto function_args = split_str($4->type, ",");
                  insert(*$2,output::makeFunctionType(*$1, function_args),0, true);
                  push_tables();
                  push_offsets(top_offsets());
                  push_regular_scope();
                  
                  vector<string> arg_names = split_str($4->id_name,",");
                  vector<string> arg_types = split_str($4->type,",");

                  assert(arg_names.size() == arg_types.size());
                  auto it_names = arg_names.begin();
                  auto it_types = arg_types.begin();
                  int offset = 0;
                  while (it_names != arg_names.end() || it_types != arg_types.end()) {
                     insert(*it_names, *it_types, --offset, false);
                     it_names++;
                     it_types++;
                  } 
                  utils_hw5::open_function(*$1, *$2, arg_names.size(), current_stack_register);
                  delete $1;
                  delete $2;
                  delete $4;
}
FuncDeclPart2:  LBRACE Statements RBRACE Marker8 {                  
}
RetType:       Type        {
                  $$ = new string(*$1);
                  delete $1;
}
               | VOID         {
                  $$ = new string(TYPE_VOID);
}
;
Formals:       /*epsilon*/       {
                  $$ = new Formal();
                  $$->type = "";
                  $$->id_name = "";
}
               | FormalsList        {
                  $$ = new Formal();
                  $$->type = $1->type;
                  $$->id_name = $1->id_name;
                  delete $1;
}
;
FormalsList:   FormalsDecl       {
                  $$ = new Formal();
                  $$->type = $1->type;
                  $$->id_name = $1->id_name;
                  delete $1;
}
               | FormalsDecl COMMA FormalsList        {
                  $$ = new Formal();
                  $$->type= ($1->type).append(",").append($3->type);
                  $$->id_name= ($1->id_name).append(",").append($3->id_name);
                  delete $1;
                  delete $3;
               }
;
FormalsDecl:   Type ID        {
                  $$ = new Formal();
                  $$->type = *$1;
                  $$->id_name = *$2;
                  delete $1;
                  delete $2;
}
;

Marker5:      { /*epsilon*/ 
                  $$ = new string(GEN_LABEL());
                  continue_labels->push(*$$);
                  vector<pair<int, BranchLabelIndex>> new_vector;
                  break_next_lists->push(new_vector);
}
;
Statements:    Statement        {
                }
               | Statements Statement        {
               }
;     
Statement:     
               /* Moved here If and While roles. solving 'Dangling Else' */
               IF LPAREN Exp NMarker1 RPAREN Marker2 Statement NMarker2     {
                  check_bool_exp($3->type);
                  //HW5:
                  vector<pair<int,BranchLabelIndex>> next_list = *$8;
                  utils_hw5::if_statement($4, *$6, next_list);
                  //HW5~
                  delete $3;
               }
               | IF LPAREN Exp NMarker1 RPAREN Marker2 Statement NMarker2 ELSE Marker2 Statement NMarker2      {
                  check_bool_exp($3->type);
                  //HW5:
                  vector<pair<int,BranchLabelIndex>> next_list = MERGE(*$8, *$12);
                  utils_hw5::if_else_statement($4,*$6,*$10, next_list);
                  //HW5~
                  delete $3;
               }
               | WHILE LPAREN NMarker3 Marker5 Exp NMarker1 RPAREN Marker4 Statement NMarker2    {
                  check_bool_exp($5->type);
                  //HW5:
                  vector<pair<int,BranchLabelIndex>> loop_branch = *$10;
                  vector<pair<int,BranchLabelIndex>> next_list;
                  next_list = MERGE(break_next_lists->top(),next_list);
                  BPATCH(CodeBuffer::makelist({$3, FIRST}),*$4);
                  utils_hw5::while_statement(*$4, $6, *$8, loop_branch, next_list);                  
                  continue_labels->pop();
                  break_next_lists->pop();
                  //HW5~
                  delete $5;
               }
               | WHILE LPAREN NMarker3 Marker5 Exp NMarker1 RPAREN Marker4 Statement NMarker2 ELSE Marker2 Statement NMarker2      {
                  check_bool_exp($5->type);
                  //HW5:
                  vector<pair<int,BranchLabelIndex>> loop_branch = *$10;
                  vector<pair<int,BranchLabelIndex>> next_list = *$14;
                  next_list = MERGE(break_next_lists->top(),next_list);
                  BPATCH(CodeBuffer::makelist({$3, FIRST}),*$4);
                  utils_hw5::while_else_statement(*$4, $6, *$8,*$12,loop_branch, next_list); 
                  continue_labels->pop();
                  break_next_lists->pop();
                  //HW5~
                  delete $5;
               }
               /* ^^^ Moved here If and While roles. solving 'Dangling Else' ^^^ */
               | LBRACE Marker7 Statements Marker3 RBRACE  {
               }
               | Type ID SC         {
                  insert(*$2,*$1, top_offsets(), false);
                  //HW5:
                  int offset = get_id_offset(*$2,*tables);
                  int stack_number = get_id_last_stack(*$2,*tables);
                  utils_hw5::store_at_offset(current_stack_register->top(),current_stack_register->get_stack_counter(),offset,-1,false);

                  //HW5~
                  top_offsets() += 1;
                  delete $1;
                  delete $2;
               }
               | Type ID ASSIGN Exp SC       {   
                  assign_type_check(*$1, $4->type);
                  insert(*$2,*$1, top_offsets(), false);
                  top_offsets() += 1;
                  // we need to check if the number is not larger then 255
                  if(!TYPE_BYTE.compare(*$1) && $4->number > 255){
                     output::errorByteTooLarge(yylineno,to_string($4->number));
                     delete $1;
                     delete $2;
                     delete $4;
                     exit(0); 
                  }
                  //HW5:
                  int offset = get_id_offset(*$2,*tables);
                  int stack_number = get_id_last_stack(*$2,*tables);
                  utils_hw5::store_at_offset(current_stack_register->top(),current_stack_register->get_stack_counter(),offset,$4->register_number);
                  //HW5~

                  delete $1;
                  delete $2;
                  delete $4;
               }
               | ID ASSIGN Exp SC         {
                  if(is_id_function(*$1, *tables)){
                     output::errorUndef(yylineno,*$1);
                     delete $1;
                     delete $3;
                     exit(0);
                  }
                  assign_type_check(get_id_type(*$1, *tables), $3->type);
                  if(!name_exists_in_table(*$1,*tables)){
                     output::errorUndef(yylineno,*$1);
                     delete $1;
                     delete $3;
                     exit(0);
                  }
                  // we need to check if the number is not larger then 255
                  // TODO: check what to do with negative numbers ?
                  if(!TYPE_BYTE.compare(get_id_type(*$1, *tables)) && $3->number > 255){
                     output::errorByteTooLarge(yylineno,to_string($3->number));
                     delete $1;
                     delete $3;
                     exit(0);
                  }
                  //HW5:
                  int offset = get_id_offset(*$1,*tables);
                  int stack_number = get_id_last_stack(*$1,*tables);
                  int stack_register = current_stack_register->top();
                  // if(offset<0){
                  //    stack_register = current_stack_register->function_stack_register;
                  // }
                  utils_hw5::assign_to_id(stack_register,offset,$3->register_number, current_stack_register->function_stack_register);
                  //HW5~
                  delete $1;
                  delete $3;
               }
               | Call SC         {
                  //HW5:
                  //HW5~
                  delete $1;
               }
               | RETURN SC       {
                  if(get_current_function_return_type(*insertion_orders).compare(TYPE_VOID)){
                     output::errorMismatch(yylineno);
                     exit(0);
                  }
                  //HW5:
                  utils_hw5::return_statement();
                  //HW5~
               }
               | RETURN Exp SC         {
                  string current_fun_return_type = get_current_function_return_type(*insertion_orders);
                  if(current_fun_return_type.compare($2->type) &&
                  (current_fun_return_type.compare(TYPE_INT) || ($2->type.compare(TYPE_BYTE)))){
                     output::errorMismatch(yylineno);
                     delete $2;
                     exit(0);
                  }
                  //HW5:
                  utils_hw5::return_statement($2->register_number);
                  //HW5~
                  delete $2;
               }
               | BREAK SC        {
                  if(!check_while_scope()){
                     output::errorUnexpectedBreak(yylineno);
                     exit(0);
                  }
                  //HW5:
                  vector<pair<int, BranchLabelIndex>> break_branch = utils_hw5::create_unconditional_branch("break");
                  if(break_next_lists->top().size() == 0){
                     break_next_lists->top() = break_branch;
                  }else{
                     break_next_lists->top() = MERGE(break_next_lists->top(),break_branch);
                  }
                  //HW5~
               }
               | CONTINUE SC        {
                  if(!check_while_scope()){
                     output::errorUnexpectedContinue(yylineno);
                     exit(0);
                  }
                  string while_label = continue_labels->top();
                  utils_hw5::create_continue_branch(while_label);
                  //HW5:
                  //HW5~
               }
;
NMarker1:      /*epsilon*/        {
      $$ = utils_hw5::gen_if_branch(($<expression>0)->register_number);
}
NMarker3:      /*epsilon*/        {
      $$ = utils_hw5::gen_branch();
}
Marker2:       /*epsilon*/        {
      // this marker pushes a scope of type regular
      push_tables();
      push_offsets(top_offsets());
      push_regular_scope();
      $$ = new string(GEN_LABEL());
      utils_hw5::open_scope(current_stack_register, false);
}
Marker7:       /*epsilon*/        {
      // this marker pushes a scope of type regular
      push_tables();
      push_offsets(top_offsets());
      push_regular_scope();
      utils_hw5::open_scope(current_stack_register, false);
}
Marker3:       /*epsilon*/        {
      //output::endScope();
      print_map_by_order(tables->back(),insertion_orders->back());
      pop_tables();
      pop_offsets();
      pop_scope();
      utils_hw5::close_scope(current_stack_register, false);
}
Marker8:       /*epsilon*/        {
      //output::endScope();
      if(get_current_function_return_type(*insertion_orders)==TYPE_VOID){
         utils_hw5::close_function(true, current_stack_register);
      }else{
         utils_hw5::close_function(false, current_stack_register);
      }
      print_map_by_order(tables->back(),insertion_orders->back());
      pop_tables();
      pop_offsets();
      pop_scope();
}
NMarker2:       /*epsilon*/        {
      //output::endScope();
      print_map_by_order(tables->back(),insertion_orders->back());
      pop_tables();
      pop_offsets();
      pop_scope();
      $$ = utils_hw5::branch_to_next_list();
      utils_hw5::close_scope(current_stack_register, false);
}

Marker4:       /*epsilon*/        {
      //this marker pushed a scope of type while
      push_tables();
      push_offsets(top_offsets());
      push_while_scope();
      $$ = new string(GEN_LABEL());
      utils_hw5::open_scope(current_stack_register, false);
}
ShortCircuitAnd:       /*epsilon*/        {
      $$ = new vector<pair<int,BranchLabelIndex>>(utils_hw5::start_short_circuit_and($<expression>-1->register_number));
}
ShortCircuitOr:       /*epsilon*/        {
      $$ = new vector<pair<int,BranchLabelIndex>>(utils_hw5::start_short_circuit_or($<expression>-1->register_number));
}

;
Call:          ID LPAREN ExpList RPAREN         {
                     // Check if the function name exists
                     if(!name_exists_in_table(*$1, *tables, true)) {                     
                        output::errorUndefFunc(yylineno, *$1);
                        delete $1;
                        delete $3;
                        exit(0);
                     }

                     // Check if given args matching the function args
                     string fun_sign = get_id_type(*$1 ,*tables);
                     string ret_type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
                     vector<string> function_args = split_str(fun_sign.substr(0,fun_sign.find("->")),",");
                     vector<string> given_args = split_str($3->type,",");

                     if(function_args.size() != given_args.size()){
                        output::errorPrototypeMismatch(yylineno,*$1,function_args);
                        delete $1;
                        delete $3;
                        exit(0);
                     }
                     for(int i=0; i< function_args.size() || i< given_args.size(); i++){
                        if(function_args[i].compare(given_args[i]) &&
                           (function_args[i].compare(TYPE_INT) || given_args[i].compare(TYPE_BYTE))) {
                              output::errorPrototypeMismatch(yylineno,*$1,function_args);
                              delete $1;
                              delete $3;
                              exit(0);
                           }
                     }

                     /* Rule #5 hw's PDF */
                     $$ = new CallFunction(ret_type);
                     // HW5:
                     if(*$1 == "print"){
                        assert($3->type == TYPE_STRING);
                        assert(($3->register_list).size() ==1);
                        string str_to_print = $3->str;
                        utils_hw5::call_function_print(($3->register_list).front(),str_to_print.size());
                     }else{
                        int output_register_number = -10;
                        if(ret_type.compare(TYPE_VOID)){
                           $$->register_number = utils_hw5::fresh_var();
                           output_register_number = $$->register_number;
                        }
                        utils_hw5::call_function(*$1,$3->register_list,output_register_number);
                     }
                     // HW5~
                     delete $1;
                     delete $3;
                  }
               | ID LPAREN RPAREN         {
                  // Check if the function name exists
                  if(!name_exists_in_table(*$1, *tables, true)) {
                     output::errorUndefFunc(yylineno, *$1);
                     delete $1;
                     exit(0);
                  }
                  string fun_sign = get_id_type(*$1 ,*tables);
                  string ret_type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
                  vector<string> function_args = split_str(fun_sign.substr(0,fun_sign.find("->")),",");
                  if(!function_args.empty()){
                     output::errorPrototypeMismatch(yylineno,*$1,function_args);
                     delete $1;
                     exit(0);
                  }

                  /* Rule #5 hw's PDF */
                  $$ = new CallFunction(ret_type);
                     // HW5:
                     int output_register_number = -10;
                     if(ret_type.compare(TYPE_VOID)){
                        $$->register_number =utils_hw5::fresh_var();
                        output_register_number = $$->register_number;
                     }
                     utils_hw5::call_function(*$1,{},output_register_number);
                     // HW5~
                  delete $1;
               }
;
ExpList:       Exp         {
                  $$ = new Expression();
                  $$->type = $1->type;
                  // HW5:
                  if($1->type == TYPE_STRING){
                     $$->str = $1->str;
                     $$->type = $1->type;
                  }
                  $$->register_list.push_back($1->register_number);
                  // HW5~
                  delete $1;
}
               | Exp COMMA ExpList        {
                  $$ = $3;
                  $$->type = ($1->type).append(",").append($3->type);
                  // HW5:
                  $$->register_list.insert($$->register_list.begin(),$1->register_number);
                  // HW5~
                  delete $1;
               }
;
Type:          INT            {
                  $$ = new string(TYPE_INT);
               }
               | BYTE         {
                  $$ = new string(TYPE_BYTE);
               }
               | BOOL         {
                  $$ = new string(TYPE_BOOL);
               }
;
Exp:           LPAREN Exp RPAREN       {
                  $$ = new Expression();
                  // $$->register_number = utils_hw5::fresh_var();
                  // no need for new register, the expression is already calculated
                  $$->register_number = $2->register_number;
                  $$->type = $2->type;
                  $$->number = $2->number;
                  // HW5:
                  // HW5~
                  delete $2;
               }
               | Exp ADD_BINOP Exp        {
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  string a_type = $1->type;
                  if(a_type.empty()){
                     a_type = get_id_type($1->id_name, *tables);
                  }
                  string b_type = $3->type;
                  if(b_type.empty()){
                     b_type = get_id_type($3->id_name, *tables);
                  }
                  // HW5:
                  $$->type = binop(a_type, b_type);
                  if(!$$->type.compare(TYPE_INT)){
                     utils_hw5::binop_int($$->register_number ,$1->register_number, *$2, $3->register_number);
                  }
                  if(!$$->type.compare(TYPE_BYTE)){
                     utils_hw5::binop_byte($$->register_number ,$1->register_number, *$2, $3->register_number);
                  }
                  // HW5~
                  delete $1;
                  delete $2;
                  delete $3;
               }
               | Exp MUL_BINOP Exp         {
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  string a_type = $1->type;
                  if(a_type.empty()){
                     a_type = get_id_type($1->id_name, *tables);
                  }
                  string b_type = $3->type;
                  if(b_type.empty()){
                     b_type = get_id_type($3->id_name, *tables);
                  }
                  $$->type = binop(a_type, b_type);
                  // HW5:
                  if(!$2->compare("*")){  // mul op
                     if(!$$->type.compare(TYPE_INT)){
                        utils_hw5::binop_int($$->register_number ,$1->register_number, *$2, $3->register_number);
                     }
                     if(!$$->type.compare(TYPE_BYTE)){
                        utils_hw5::binop_byte($$->register_number ,$1->register_number, *$2, $3->register_number);
                     }
                  }else{ // div op
                     utils_hw5::binop_div($$->register_number ,$1->register_number, $3->register_number);
                  }
                  // HW5~
                  delete $1;
                  delete $2;
                  delete $3;
               }
               | ID        {
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  $$->type = get_id_type(*$1, *tables);
                  int offset = get_id_offset(*$1,*tables);
                  utils_hw5::load_id_to_reg(offset, $$->register_number);
                  delete $1;
               }
               | Call         {
                  $$ = new Expression();
                  $$->type = $1->return_type;
                  // HW5:
                  if(!$1->return_type.compare(TYPE_VOID)){
                     //error
                     output::errorMismatch(yylineno);
                     exit(0);
                  }
                  $$->register_number = $1->register_number;
                  // HW5~
                  delete $1;
               }
               | NUM       {
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  $$->type = TYPE_INT;
                  $$->number = $1;
                  //HW5:
                  utils_hw5::assign_number_to_register($$->register_number,$1);
                  //HW5~
               }
               | NUM B       {
                  if($1 > 255){
                     output::errorByteTooLarge(yylineno,to_string($1));
                  }
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  $$->type = TYPE_BYTE;
                  $$->number = $1;  
                  //HW5:
                  utils_hw5::assign_number_to_register($$->register_number,$1);
                  //HW5~
               }
               | STRING       {
                  // String is an internal type
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  $$->str=$1->substr(1,$1->size()-2);  
                  $$->type= TYPE_STRING;
                  //HW5:
                  utils_hw5::add_string_constant($$->str,$$->register_number);
                  //HW5~
                  delete $1;
               }
               | TRUE         {
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  $$->bool_value=true;
                  $$->type = TYPE_BOOL;
                  //HW5:
                  utils_hw5::assign_number_to_register($$->register_number,1);
                  //HW5~
               }
               | FALSE        {
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  $$->bool_value=false;
                  $$->type = TYPE_BOOL;
                  //HW5:
                  utils_hw5::assign_number_to_register($$->register_number,0);
                  //HW5~
               }
               | NOT Exp         {
                  //TODO: Nadav
                  $$ = new Expression();
                  check_bool_exp($2->type);
                  $$->type = $2->type;
                  // HW5:
                  $$->register_number = utils_hw5::fresh_var();
                   utils_hw5::flip_bool_value($$->register_number,$2->register_number);
                  // HW5~
                  delete $2;
               }
               |  Exp AND ShortCircuitAnd Exp    {
                  $$ = new Expression();
                  string a_type = $1->type;
                  if(a_type.empty()){
                     a_type = get_id_type($1->id_name, *tables);
                  }
                  string b_type = $4->type;
                  if(b_type.empty()){
                     b_type = get_id_type($4->id_name, *tables);
                  }
                  $$->type = log_eq(a_type, b_type);
                  // HW5:
                  $$->register_number = utils_hw5::fresh_var();
                  utils_hw5::close_short_circit_and($4->register_number, *$3, $$->register_number);
                  // HW5~
                  delete $1;
                  delete $3;
                  delete $4;
               }
               | Exp  OR ShortCircuitOr Exp      {
                  $$ = new Expression();
                  string a_type = $1->type;
                  if(a_type.empty()){
                     a_type = get_id_type($1->id_name, *tables);
                  }
                  string b_type = $4->type;
                  if(b_type.empty()){
                     b_type = get_id_type($4->id_name, *tables);
                  }
                  $$->type = log_eq(a_type, b_type);
                  // HW5:
                  $$->register_number = utils_hw5::fresh_var();
                  utils_hw5::close_short_circit_or($4->register_number, *$3, $$->register_number);
                  // HW5~
                  delete $1;
                  delete $3;
                  delete $4;
               }
               | Exp EQUALITY_RELOP Exp        {
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  string a_type = $1->type;
                  if(a_type.empty()){
                     a_type = get_id_type($1->id_name, *tables);
                  }
                  string b_type = $3->type;
                  if(b_type.empty()){
                     b_type = get_id_type($3->id_name, *tables);
                  }
                  $$->type = relop(a_type, b_type);
                  //HW5:
                  utils_hw5::relop($$->register_number,$1->register_number, *$2,$3->register_number);
                  //HW5~
                  delete $1;
                  delete $2;
                  delete $3;
               }
               | Exp RELATIONAL_RELOP Exp         {
                  $$ = new Expression();
                  $$->register_number = utils_hw5::fresh_var();
                  string a_type = $1->type;
                  if(a_type.empty()){
                     a_type = get_id_type($1->id_name, *tables);
                  }
                  string b_type = $3->type;
                  if(b_type.empty()){
                     b_type = get_id_type($3->id_name, *tables);
                  }
                  $$->type = relop(a_type, b_type);
                  //HW5:
                  utils_hw5::relop($$->register_number,$1->register_number, *$2,$3->register_number);
                  //HW5~
                  delete $1;
                  delete $2;
                  delete $3;
               }

;
%%

bool name_exists_in_table(const string name,const vector<map<string, pair<string, int>>> &tables, bool is_fun){
   /*
   * this function will get a pointer to a string representing a name and a stack of tables
   * the function will return true if the name is already in the tables and false otherwise
   */
   // stack<map<string, pair<string, int>>> *tabels_clone = new stack<map<string, pair<string, int>>>(tables);
   for(auto map_iterator = tables.end()-1 ; map_iterator >=tables.begin() ; map_iterator-- ){
      auto id_iterator= map_iterator->find(name);
      if (id_iterator != map_iterator->end()) {
            // if reached here, that means the key already is in some table
            if(is_fun){
               string id_type = id_iterator->second.first;
               if(id_type.find("->") == string::npos){
                  return false;
               }
            }
            // if reached here, that means the key already is in some table
            return true;
      }
   }
   return false;
} 

/* Rule #8 hw's PDF */
string relop(string a, string b){
   if ((!a.compare(TYPE_INT) || !a.compare(TYPE_BYTE)) && (!b.compare(TYPE_INT) || !b.compare(TYPE_BYTE))) {
      // Both must be numbers
      return TYPE_BOOL;
   }
   output::errorMismatch(yylineno);
   exit(0);
}


/* Rule #9 hw's PDF */
string log_eq(string a, string b){
   if (!a.compare(TYPE_BOOL) && !b.compare(TYPE_BOOL)) {
      // Both must be boolean
      return TYPE_BOOL;
   }
   output::errorMismatch(yylineno);
   exit(0);
}

/* Rule #10 hw's PDF */
string binop(string a, string b){
   if(!a.compare(TYPE_STRING) || !b.compare(TYPE_STRING)){
      output::errorMismatch(yylineno);
      exit(0);
   }
   if(!a.compare(b)){
      /* Both expressions have the same type */
      return a;
   }
   if((!a.compare(TYPE_INT) && !b.compare(TYPE_BYTE))
   || (!a.compare(TYPE_BYTE) && !b.compare(TYPE_INT))){
      return TYPE_INT;
   }
   output::errorMismatch(yylineno);
   exit(0);
}

/* Rule #16 hw's PDF */
void check_bool_exp(string exp_type){
   if(exp_type == ""){
      return;
   }
   if(exp_type.compare(TYPE_BOOL)){
      output::errorMismatch(yylineno);
      exit(0);
   }
}


void pop_tables(){
   tables->pop_back();
   insertion_orders->pop_back();
}
void pop_offsets(){
   offsets->pop();
}
void push_tables(){
   tables->push_back(map<string,pair<string, int>>());
   insertion_orders->push_back(queue<string>());
   
}
void push_offsets(int offset){
   offsets->push(offset);
}
map<string,pair<string, int>> &top_tables(){
   return tables->back();
}

int &top_offsets(){
   return offsets->top();
}

void insert(const string& name, const string& type,int offset, bool is_fun){
   if(name_exists_in_table(name,*tables)){
      output::errorDef(yylineno,name);
      exit(0);
   }
   (tables->back()).insert({
         name,
         pair<string ,int>(type,offset)
   });
   insertion_orders->back().push(name);
}

void yyerror(const char*){
   output::errorSyn(yylineno); 
}

void push_regular_scope(){
   auto new_scope = Scope(REGULAR_SCOPE);
   scopes->push_back(new_scope);
}

void pop_scope(){
   scopes->pop_back();
}
void push_while_scope(){
   auto new_scope = Scope(WHILE_SCOPE);
   scopes->push_back(new_scope);
}

bool check_while_scope(){
   for(Scope it : (*scopes)){
      if(it.get_scope_type() == WHILE_SCOPE){
         return true;
      }
   }
   return false;
}




void assign_type_check(string var,string exp) {
   // the string compare function will return 0 (false) only if the string are the same
   if(var.compare(exp)){
      if(var.compare(TYPE_INT) || exp.compare(TYPE_BYTE))  {
         output::errorMismatch(yylineno);
         exit(0);
      }
   }
   return;
}



string get_current_function_return_type(const vector<queue<string>> stack_queues){
   string function_name = stack_queues.front().back();
   string function_sign = get_id_type(function_name , *tables);
   return function_sign.substr(function_sign.find("->")+2, function_sign.size()-1);
}

string vectorToString(const std::vector<string>& argTypes) {
   string res;
   res = "(";
   for(int i = 0; i < argTypes.size(); ++i) {
      res.append(argTypes[i]);
      if (i + 1 < argTypes.size())
         res.append(",");
   }
   res.append(")");
   return res;
}

   string get_id_type(const string name, const vector<map<string, pair<string, int>>> &tables){
   // stack<map<string, pair<string, int>>> *tabels_clone = new stack<map<string, pair<string, int>>>(tables);
   for(auto map_iterator = tables.end()-1 ; map_iterator >= tables.begin() ; map_iterator-- ){
      auto id_iterator= map_iterator->find(name);
      if (id_iterator != map_iterator->end()) {
            // if reached here, that means the key already is in some table
            string id_type = id_iterator->second.first;
            return id_type;
      }
   }
   output::errorUndef(yylineno, name);
   exit(0);
}

int get_id_offset(const string name, const vector<map<string, pair<string, int>>> &tables){
   for(auto map_iterator = tables.end()-1 ; map_iterator >= tables.begin() ; map_iterator-- ){
      auto id_iterator= map_iterator->find(name);
      if (id_iterator != map_iterator->end()) {
         // if reached here, that means the key already is in some table
         int offset = id_iterator->second.second;
         return offset;
      }
   }
   output::errorUndef(yylineno, name);
   exit(0);
}

int get_id_last_stack(const string name, const vector<map<string, pair<string, int>>> &tables){
   int stack_number = current_stack_register->get_stack_counter()  -1;
   for(auto map_iterator = tables.end()-1 ; map_iterator >= tables.begin() ; map_iterator-- ){
      auto id_iterator= map_iterator->find(name);
      if (id_iterator != map_iterator->end()) {
         // if reached here, that means the key already is in some table
         return stack_number;
      }
      stack_number--;
   }
   output::errorUndef(yylineno, name);
   exit(0);
}

bool is_id_function(const string& name, const vector<map<string, pair<string, int>>> &tables){
   string type = get_id_type(name, tables);
   return (type.find("->") != string::npos);
}

int get_id_dest_from_last_scope(const string name, const vector<map<string, pair<string, int>>> &tables){
   int dest_from_last = 0;
   for(auto map_iterator = tables.end()-1 ; map_iterator >= tables.begin() ; map_iterator-- ){
      auto id_iterator= map_iterator->find(name);
      if (id_iterator != map_iterator->end()) {
         // if reached here, that means the key already is in some table
         return dest_from_last;
      }
      dest_from_last++;
   }
   output::errorUndef(yylineno, name);
   exit(0);
}

vector<string> split_str(string str, string delimiter){
   if(str[0] == '('){
      str.erase(0,1);
   }
   if(str[str.length()-1] == ')'){
      str.erase(str.length()-1,1);
   }
   vector<string> tokens;
   size_t position = 0;
   while ((position = str.find(delimiter)) != string::npos) {
      tokens.push_back(str.substr(0, position));
      str.erase(0,position + delimiter.length());
   }
   if(tokens.size()!=0 || !str.empty()){
      tokens.push_back(str);
   }
   return tokens;
}
void print_map_by_order(map<string, pair<string, int>> scope_map,queue<string> orders){
   queue<string>* clone = new queue<string> (orders);
   string name;
   while (clone->size()!= 0){
      name = clone->front();
      clone->pop();
      auto element = scope_map[name];
      //output::printID(name, element.second, element.first);
   }
   delete clone;
}

int main(){
   tables = new vector<map<string,pair<string, int>>>();
   offsets = new stack<int>();
   insertion_orders = new vector<queue<string>> ();
   scopes = new vector<Scope>();
   current_stack_register = new CurrentStackRegister();
   break_next_lists = new stack<vector<pair<int, BranchLabelIndex>>>();
   continue_labels = new stack<string>();
   auto return_parse = yyparse();
   delete tables;
   delete offsets;
   delete insertion_orders;
   delete scopes;
   delete continue_labels;
   delete break_next_lists;
   return return_parse;
}